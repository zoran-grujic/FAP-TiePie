#  Copyright (c) 2021.
#  This code has been produced by Zoran D. Grujic and by the knowledge found on The Internet.
#  Please feel free to ask me for permission to use my code in your own projects. It is for your own well fare!
#  pyinstaller --onefile -w app.pyw

# ---------------------------------------------
# to find QtDesigner and pyuic5 files goto
# C:\Users\Zoran\Anaconda3\Library\bin
# C:\Users\Zoran\Anaconda3\Library\bin\pyuic5 gui.ui -o gui.py

# pip install qdarkgraystyle
import qdarkgraystyle  # https://pypi.org/project/qdarkgraystyle/

from PyQt5.QtCore import QThreadPool
from QtWorker import Worker
import sys
import os
import logging
from PyQt5 import QtCore  # conda install pyqt // pip install PyQt5==5.15.0
from PyQt5 import QtWidgets
#from PyQt5.QtWidgets import QMessageBox, QWidget
#from PyQt5 import QtGui
# pip install pyqtgraph
import pyqtgraph as pg  # Fast plot package
import numpy as np
from scipy import signal, stats
import time
from datetime import datetime
from scipy.optimize import curve_fit
from arbcalc import arbcalc
from tiepieArb import arbGenerator
from tiepieSCP import oscilloscope
import CrameRaoFunctions as cr
import shutil  # about disk remaining memory

from gui import Ui_MainWindow  # generated by designer, DO NOT EDIT
# pip install python-libtiepie
import libtiepie
from playsound import playsound  # pip install playsound
#import traceback
import collections
from scipy.interpolate import CubicSpline
import glob

import class_MySerial as myserial


# extend Ui_MainWindow class
class MyUi(Ui_MainWindow):
    plotWindow = pg.GraphicsLayoutWidget()  # pg.GraphicsWindow() Deprecated
    FITplotWindow_Widget = pg.GraphicsLayoutWidget()  # pg.GraphicsWindow() Deprecated
    monitorPlot_Window = pg.GraphicsLayoutWidget()  # pg.GraphicsWindow()
    probeStabPlot_Window = pg.GraphicsLayoutWidget()  # pg.GraphicsWindow()
    vcsellPlot_Window = pg.GraphicsLayoutWidget()  # pg.GraphicsWindow()
    timerPlotSCP = QtCore.QTimer()
    timerStart = QtCore.QTimer()

    timerScanSaveDelay = QtCore.QTimer()
    scanRunning = False
    scanIndex = 0
    scan_values=[]
    scan_results=[]

    rePlotInterval_ms = 100
    SCPData = False
    dataFITtab = False

    colorX = (100, 200, 250)
    colorY = (100, 250, 200)
    colorZ = (250, 100, 200)
    penX = pg.mkPen(colorX, width=2, style=QtCore.Qt.PenStyle.SolidLine)
    penY = pg.mkPen(colorY, width=2, style=QtCore.Qt.PenStyle.SolidLine)
    penZ = pg.mkPen(colorZ, width=2, style=QtCore.Qt.PenStyle.SolidLine)
    decimationArr = np.array([5])  # 5,2

    countRemainingToSave = 0

    soundPlayed = False
    ProbePower = 1 #calculated mean probe power to be used for stabilization
    esp32 = False  # serial connection to ESP32 driver of MAX11300 12bit 20ch I/O chip
    probeStabOut = collections.deque(maxlen=500)
    probeStabError = collections.deque(maxlen=500)
    probeStabTimestamp = collections.deque(maxlen=500)
    VCSELLOut = collections.deque(maxlen=500)
    VCSELLTimestamp = collections.deque(maxlen=500)
    VCSELLSpectrumLoaded = [False, False]



    """Initialize the app"""

    def __init__(self):
        super(MyUi, self).__init__()

        self.dialogs = list()

        self.gen = arbGenerator()
        self.scp = oscilloscope()

        self.threadpool = QThreadPool()
        self.theWorkerBlocks = Worker(self.getBlocks)  # Any other args, kwargs are passed to the run function
        self.theWorkerSave = Worker(self.SaveData)  # Any other args, kwargs are passed to the run function
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())

        self.timerPlotSCP.setInterval(self.rePlotInterval_ms)
        self.timerPlotSCP.timeout.connect(self.plotSCP)

        self.timerStart.setInterval(1000)
        self.timerStart.timeout.connect(self.boot)

        #self.okButton_RangeScanStart
        #self.timerScanSaveDelay.setInterval(2000)

        self.theWorkerBlocks_enabled = True

        self.esp32 = myserial.MySerial()
        self.esp32.connect()




    """
    override function of the parent class to connect actions and buttons
    set user interface
    """
    def setupUi(self, MainWindow):
        super(MyUi, self).setupUi(MainWindow)  # call function of the parent class
        self.refreshSpectrumFolderCombo() # should be performed before loading settings
        self.loadSettings()

        self.okButton_GeneratorStart.clicked.connect(self.genStartStop)
        self.okButton_RangeScanStart.clicked.connect(self.rangeScanStartStop)
        self.tabWidget.currentChanged.connect(self.tabChanged)
        #self.pushButton_SaveScanToFile.clicked.connect(self.)

        self.doubleSpinBox_RecordsToSave.valueChanged.connect(self.saveRecordsChanged)

        self.doubleSpinBox_stabProbePowerOut.valueChanged.connect(self.stabProbePowerOutChanged)
        self.doubleSpinBox_stabVCSELLOut.valueChanged.connect(self.stabVCSELLOutChanged)

        self.actionSave_settings.triggered.connect(self.actionSave_settings_handler)
        self.actionLoad_settings.triggered.connect(self.actionLoad_settings_handler)

        self.pushButton_SaveVCSELLSpectrum.clicked.connect(self.saveVCSELLSpectrum)
        self.pushButton_LoadVCSELLSpectrum.clicked.connect(self.loadVCSELLSpectrum)

        elements = [self.doubleSpinBox_PumpLevel,
                    self.doubleSpinBox_ProbeLevel,
                    self.doubleSpinBox_ZeroLevel,
                    self.doubleSpinBox_Frequency_Hz,
                    self.doubleSpinBox_TotalTime_ms,
                    self.doubleSpinBox_DutyCycle,
                    self.doubleSpinBox_PumpTime_ms,
                    self.doubleSpinBox_Points,
                    self.doubleSpinBox_ExpAmplitude,
                    self.doubleSpinBox_ExpRelaxation
                    ]
        for el in elements:
            el.valueChanged.connect(self.arbSet)

        elements = [self.doubleSpinBox_FilterStart_ms,
                    self.doubleSpinBox_FilterStop_ms,
                    self.doubleSpinBox_FIT_f0,
                    self.doubleSpinBox_FIT_A,
                    self.doubleSpinBox_FIT_B,
                    self.doubleSpinBox_FIT_Gamma,
                    self.doubleSpinBox_FIT_DC
                    ]
        for el in elements:
            el.valueChanged.connect(self.fit)
        self.comboBox_FilterType.currentIndexChanged.connect(self.fitUISet)
        self.radioButton_FITSource_CH1.clicked.connect(self.fitUISet)
        self.radioButton_FITSource_CH2.clicked.connect(self.fitUISet)
        self.pushButton_Set_FIT_init.clicked.connect(self.copyFITtoInit)
        self.pushButton_SelectFolder.clicked.connect(self.selectFolder)
        self.lineEdit_FolderName.setText(os.getcwd()+"\\data\\")
        self.comboBox_trigger.currentIndexChanged.connect(self.trigger_changed)

        # change CH parameters on the data tab
        elements = [
            self.comboBox_CH1Range,
            self.comboBox_CH2Range,
            self.radioButton_CH1AC,
            self.radioButton_CH2AC
        ]
        for el in elements:
            self.connectElementTo(el, self.setCH_1_2)

        # make stab/Lock plot widget and layout
        containing_layout = self.widget_PlotVCSELL.parent().layout()
        containing_layout.replaceWidget(self.widget_PlotVCSELL, self.vcsellPlot_Window)
        PG_layout_vcsell = pg.GraphicsLayout()  # make layout for plots

        self.vcsellSpectrumPlot = PG_layout_vcsell.addPlot()
        PG_layout_vcsell.nextRow()
        self.vcsellOutPlot = PG_layout_vcsell.addPlot()
        PG_layout_vcsell.nextRow()
        self.vcsellCorrPlot = PG_layout_vcsell.addPlot()
        self.vcsellPlot_Window.setCentralItem(PG_layout_vcsell)  # set layout to the widget

        # make stab/Lock plot widget and layout
        containing_layout = self.widget_PlotStab.parent().layout()
        containing_layout.replaceWidget(self.widget_PlotStab, self.probeStabPlot_Window)
        PG_layout_stab = pg.GraphicsLayout()  # make layout for plots

        self.errorProbeStabPlot = PG_layout_stab.addPlot()
        PG_layout_stab.nextRow()
        self.outProbeStabPlot = PG_layout_stab.addPlot()
        self.probeStabPlot_Window.setCentralItem(PG_layout_stab)  # set layout to the widget

        # make plot widget and layout
        containing_layout = self.PlotPlaceholder.parent().layout()
        containing_layout.replaceWidget(self.PlotPlaceholder, self.plotWindow)
        PG_layout = pg.GraphicsLayout()  # make layout for plots

        self.arbPlot = PG_layout.addPlot()
        PG_layout.nextRow()
        self.ch1Plot = PG_layout.addPlot()
        self.ch1Plot_lr = pg.LinearRegionItem([15, 16], hoverBrush=None)
        self.ch1Plot_lr.setZValue(10)

        self.ch1Plot_lrM = pg.LinearRegionItem([self.doubleSpinBox_TotalTime_ms.value(), self.doubleSpinBox_TotalTime_ms.value()-1], hoverBrush=None)
        self.ch1Plot_lrM.setZValue(10)
        #self.ch1Plot_lr.sigRegionChangeFinished.connect(self.something)


        PG_layout.nextRow()
        self.ch2Plot = PG_layout.addPlot()

        self.plotWindow.setCentralItem(PG_layout)  # set layout to the widget
        for chkbox in [self.checkBox_SaveData]:  # , self.checkBox_StabProbePower, self.checkBox_VCSELLStab
            chkbox.setStyleSheet("QCheckBox::indicator { width: 70; height: 70;}")

        containing_layout = self.FITPlotPlaceholder.parent().layout()
        containing_layout.replaceWidget(self.FITPlotPlaceholder, self.FITplotWindow_Widget)
        PG_layout_Tab_2 = pg.GraphicsLayout()  # make layout for plots

        self.dataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.unFilteredDataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextRow()
        self.FITdataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.FFTdataPlotFIT = PG_layout_Tab_2.addPlot()
        self.FFTdataPlotFIT_lr = pg.LinearRegionItem([1500, 3000], hoverBrush=None)
        self.FFTdataPlotFIT_lr.setZValue(10)
        self.FFTdataPlotFIT_lr.sigRegionChanged.connect(self.updateCRRange)


        PG_layout_Tab_2.nextRow()
        self.ResidualsDataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.FFTFilteredDataPlotFIT = PG_layout_Tab_2.addPlot()
        self.FFTFilteredDataPlotFIT_lr = pg.LinearRegionItem([1500, 3000], hoverBrush=None)
        self.FFTFilteredDataPlotFIT_lr.setZValue(10)
        self.FFTFilteredDataPlotFIT_lr.sigRegionChangeFinished.connect(self.updateCR)

        self.FITplotWindow_Widget.setCentralItem(PG_layout_Tab_2)

        # make Monitor plot widget
        containing_layout = self.CH_MonitorPlotPlaceholder.parent().layout()
        containing_layout.replaceWidget(self.CH_MonitorPlotPlaceholder, self.monitorPlot_Window)
        PG_layout_Tab_Monitor = pg.GraphicsLayout()  # make layout for plots

        self.monitorPlotCH1 = PG_layout_Tab_Monitor.addPlot()
        PG_layout_Tab_Monitor.nextRow()
        self.monitorPlotCH2 = PG_layout_Tab_Monitor.addPlot()
        if(self.scp.channels>2):
            PG_layout_Tab_Monitor.nextRow()
            self.monitorPlotCH3 = PG_layout_Tab_Monitor.addPlot()
            PG_layout_Tab_Monitor.nextRow()
            self.monitorPlotCH4 = PG_layout_Tab_Monitor.addPlot()

        self.monitorPlot_Window.setCentralItem(PG_layout_Tab_Monitor)

        # Set tab index
        self.tabWidget.setCurrentIndex(0)

        # Execute
        self.scpWorkerStart(self.theWorkerBlocks)
        self.timerPlotSCP.start()
        # self.genStartStop()

        self.showDiskSpace()

        self.plainTextEdit_ESP32SerialLog.appendHtml(
            f"<font color=green>PORT: {self.esp32.port} status: {self.esp32.status}</font>")
        self.updateConnectionInfo()

        # change CH parameters on the data tab
        elements = [
            self.checkBox_VRangeScan,
            self.checkBox_AmplitudeRangeScan,
            self.doubleSpinBox_scan_minOutV,
            self.doubleSpinBox_scan_maxOutV,
            self.doubleSpinBox_VScanIntervals,
            self.doubleSpinBox_scan_minAmplitude,
            self.doubleSpinBox_scan_maxAmplitude,
            self.doubleSpinBox_AmplitudeScanIntervals
        ]
        for el in elements:
            self.connectElementTo(el, self.ScanValuesGenerate)

        self.MAX11300out(self.doubleSpinBox_stabVCSELLOut.value(), ch=1)
        self.MAX11300out(self.doubleSpinBox_stabProbePowerOut.value(), ch=0)

        self.loadVCSELLSpectrum()

        # Update trigger sources based on channel count
        trigger_sources = ["Generator"]
        n_channels = len(self.scp.scp.channels)
        for i in range(n_channels):
            trigger_sources.append(f"CH{i + 1}")
        self.comboBox_trigger.clear()
        self.comboBox_trigger.addItems(trigger_sources)


    def refreshSpectrumFolderCombo(self):
        #fl = glob.glob("./spectrums/*")
        fl = subfolders = [  os.path.basename(f.path) for f in os.scandir("./spectrums/") if f.is_dir() ]
        self.comboBox_SelectVCSELLSpectrum.clear()
        self.comboBox_SelectVCSELLSpectrum.addItems(fl)

        #self.comboBox_SelectVCSELLSpectrum
    def scpWorkerStart(self, worker):

        print("Boot SCP")
        self.scpSet()
        try:
            worker.signals.result.connect(self.res)
            worker.signals.finished.connect(self.fini)
            worker.signals.progress.connect(self.prog)

            # Execute
            self.threadpool.start(worker)
            print("Worker read SCP data Started")
        except Exception as e:
            print("scpWorkerStart exception: ", e)

    def scpWorkerStop(self, worker):
        try:
            self.theWorkerBlocks_enabled = False

            self.threadpool.stop(worker)
        except Exception as e:
            print("scpWorkerStop exception: ", e)

    def SaveData(self, progress_callback):
        pass

    def saveData(self, data):
        try:
            self.showDiskSpace()
            now = datetime.now()  # current date and time
            date_time = now.strftime("%Y%m%d_%H-%M-%S-%f")
            print("date and time:", date_time)
            fn = self.lineEdit_FolderName.text() + self.lineEdit_FileNamePrefix.text() + date_time
            decimated = data
            if self.comboBox_decimate.currentText() != "None":
                decFactor = int(self.comboBox_decimate.currentText())
                if decFactor <= 10:
                    decimationArr = [decFactor]
                else:
                    if decFactor <= 100:
                        decimationArr = [10, int(decFactor/10)]
                    else:  # up to 1000
                        decimationArr = [10, 10, int(decFactor / 100)]

                for d in decimationArr:
                    decimated = signal.decimate(decimated, d, ftype='fir')
            np.save(fn, decimated)
            print("File: ", fn)
            return True
        except Exception as e:
            print("Save data Exception:", e)

            # stop saving?
            try:
                playsound('Sounds/retro-game-over-213.wav')
            except:
                pass
            self.checkBox_SaveData.setChecked(False)
            self.countRemainingToSave = 0

        return False

    def getBlocks(self, progress_callback):
        print("Worker here")

        scp = self.scp.scp
        while self.theWorkerBlocks_enabled:
            if self.radioButton_modeBlock.isChecked():
                # block mode
                if scp.is_running and scp.measure_mode == libtiepie.MM_STREAM:
                    # change from STREAM to BLOCK

                    self.scpSet() # set

                    if self.scp.status_settings_changed:
                        scp.stop()
                        while scp.is_running:
                            time.sleep(0.01)  # wait for stop
                        print("SCP settings changed, stopped SCP")
                        self.scpSet() #set when stooped
                        scp.start()
                        while not scp.is_running:
                            time.sleep(0.01)  # wait for start
                        print("SCP started after settings changed")
                else:
                    self.scpSet()  # set SCP parameters
                    if scp.is_running:
                        scp.stop()
                    scp.start()
                # Wait for measurement to complete:
                while not scp.is_data_ready:
                    time.sleep(0.01)  # 10 ms delay, to save CPU time

                # Get data:
                self.SCPData = scp.get_data()
                # print("Got SCP data!")
                # print(f"scp {scp.sample_rate=}")
                # print(f" self.SCPData len = {len(self.SCPData[0])}")
            else:
                # stream mode
                # print("Stream mode")
                if scp.measure_mode == libtiepie.MM_BLOCK:
                    # change from BLOCK to STREAM
                    self.scpSet()
                    scp.start()
                else:
                    if not scp.is_running:
                        scp.start()

                while not scp.is_data_ready:
                    time.sleep(0.01)  # 10 ms delay, to save CPU time

                # Get data:
                self.SCPData = scp.get_data()
                #print("Got SCP data!")
                #print(f"scp {scp.sample_rate=}")
            # print(scp.measure_mode)
            if self.checkBox_SaveData.isChecked():
                self.doubleSpinBox_RecordsToSave.setDisabled(True)
                self.saveData(self.SCPData)

                #count remaining to save
                n = int(self.doubleSpinBox_RecordsToSave.value())
                if self.countRemainingToSave == n: #first file
                    self.soundPlayed = False
                if n != 0:
                    self.countRemainingToSave -= 1
                    self.label_RemainingToSave.setText("Remaining: " + str(self.countRemainingToSave))
                    if self.countRemainingToSave <= 0:
                        self.countRemainingToSave = n
                        self.checkBox_SaveData.setChecked(False)
            else:
                self.doubleSpinBox_RecordsToSave.setDisabled(False)
                self.label_RemainingToSave.setText("Finished")
                if not self.soundPlayed:
                    playsound('Sounds/retro-game-notifi.wav')
                    self.soundPlayed = True


    def plotArb(self, t, y):

        self.arbPlot.clear()
        self.arbPlot.plot(1000 * t, y)
        self.arbPlot.setLabel('bottom', "time (ms)")
        self.arbPlot.setLabel('left', "S (V)")

        scp = self.scp.scp
        if scp is None or (scp.is_running and scp.measure_mode == libtiepie.MM_STREAM):
            # not controlable
            self.statusbar.showMessage("Oscilloscope and Arb. signal Generator are not controllable in STREAM mode!",
                                       2000)
            return False

        if not self.timerPlotSCP.isActive():
            self.timerPlotSCP.start()

    # not in use?
    def getOscData(self):
        self.scpSet()
        self.SCPData = self.scp.getBlock()

        print("Current tab index: " + str(self.tabWidget.currentIndex()))
        self.plotSCPMonitor()
        self.plotSCP()

    def plotSCP(self):

        if self.tabWidget.currentIndex() == 2:  # Monitor tab
            return self.plotSCPMonitor()
        if self.tabWidget.currentIndex() not in [0, 3]:  # Data tab or Stabilization/Lock
            return


        if isinstance(self.SCPData, bool):
            return
        samples = len(self.SCPData[0])
        if samples < 10:
            return

        sr = self.scp.scp.sample_rate
        t = np.linspace(0, 1000 * samples / sr, samples, endpoint=False)

        # print(f"plotSCP: {samples=}, {sr=}")

        fltr = signal.firwin(51, [2e3,50e3], pass_zero=False, fs=sr)

        self.ch1Plot.clear()
        self.ch2Plot.clear()

        self.ch1Plot.setLabel('bottom', "time (ms)")
        self.ch1Plot.setLabel('left', "CH1 (V)")
        self.ch1Plot.plot(t, self.SCPData[0])
        redPen = pg.mkPen('r', width=2, style=QtCore.Qt.DashLine)
        grid = pg.GridItem(pen=redPen)
        grid.setTickSpacing(x=[1e5], y=[float(self.comboBox_CH1Range.currentText())])
        self.ch1Plot.addItem(grid)
        vr = self.ch1Plot.getViewBox().viewRange()

        # Region for amplitude estimation
        rst = self.doubleSpinBox_PumpTime_ms.value()+.5
        if rst + 1 > self.doubleSpinBox_TotalTime_ms.value():
            rst = self.doubleSpinBox_TotalTime_ms.value()-2
        self.ch1Plot_lr.setRegion((rst, rst+1))
        self.ch1Plot.addItem(self.ch1Plot_lr)

        self.ch1Plot_lrM.setRegion((self.doubleSpinBox_TotalTime_ms.value()-5, self.doubleSpinBox_TotalTime_ms.value()))
        self.ch1Plot.addItem(self.ch1Plot_lrM)

        # get signal amplitude
        start, stop = self.ch1Plot_lr.getRegion()
        tSel = (t > start) & (t < stop)
        #print(tSel)
        elValsCH1 = np.array(self.SCPData[0])[tSel]

        filtered = signal.convolve(elValsCH1, fltr, mode='valid')

        min= np.min(filtered)
        max = np.max(filtered)
        amplitude = .92*(max-min)/2
        self.amplitude = amplitude
        text = pg.TextItem(f"{(1e3*amplitude):.2f}")
        self.ch1Plot.addItem(text)

        # print(vr[1][1])
        text.setPos(rst + 1, vr[1][1])

        # get mean probe at the end
        start, stop = self.ch1Plot_lrM.getRegion()
        tSel = (t > start) & (t < stop)
        # print(tSel)
        mvValsCH1 = np.array(self.SCPData[0])[tSel]
        meanProbe = np.mean(mvValsCH1)
        self.ProbePower = meanProbe + self.doubleSpinBox_SignalOffset.value()
        self.stabilizeProbe()
        self.stabilizeVCSELL()

        textmean = pg.TextItem(f"{(1e3 * (self.ProbePower)):.2f}")
        textmean.setPos(self.doubleSpinBox_TotalTime_ms.value() * .9, vr[1][1])
        self.ch1Plot.addItem(textmean)

        #self.ch1Plot.setLabel('top', f"{amplitude=}")

        self.ch2Plot.setLabel('bottom', "time (ms)")
        self.ch2Plot.setLabel('left', "CH2 (V)")
        self.ch2Plot.plot(t, self.SCPData[1])

    def stabilizeVCSELL(self):
        #print("stab VCSELL")

        #print("stab VCSELL is ON")
        self.doubleSpinBox_stabVCSELLOut.setReadOnly(True)
        onePumpPeriod = 1.0 / self.doubleSpinBox_Frequency_Hz.value()
        nPumpPeriods = int(self.doubleSpinBox_PumpTime_ms.value()/1000 / onePumpPeriod)
        points = self.doubleSpinBox_Samples.value()  # no of samples in a scp block
        totaltime= self.doubleSpinBox_TotalTime_ms.value()/1000
        samplePumpPeriod = points * onePumpPeriod/totaltime

        if self.comboBox_trigger.currentText()=="Generator":
            stop = int(nPumpPeriods * samplePumpPeriod + self.doubleSpinBox_stabSpectrumShift.value())
            start = int(stop - samplePumpPeriod)
        else:
            # if CH1 or CH2... we take first period.

            stop = int(2 * samplePumpPeriod + self.doubleSpinBox_stabSpectrumShift.value())
            start = int(stop - samplePumpPeriod)

        #print(f"{onePumpPeriod=}   {nPumpPeriods=}")
        #print(f"{start=}   {stop=}")
        spectrum = self.SCPData[1][start:stop]  # CH2 data
        #t = 1000* np.linspace(0, onePumpPeriod, len(spectrum), endpoint=False)
        #print(f"{spectrum=}")

        # spline to have always same number of 140 points
        num = 140
        x = np.linspace(0, num, num=len(spectrum), endpoint=False)
        cs = CubicSpline(x, spectrum)
        xs = np.linspace(0, num, num=num, endpoint=False)
        spectrumSpline = cs(xs)

        self.vcsellSpectrumPlot.clear()
        self.vcsellSpectrumPlot.plot(xs, spectrumSpline)
        self.vcsellSpectrumPlot.setLabel('left', "VCSELL spectrum")
        self.vcsellSpectrumPlot.setLabel('bottom', "#")

        # correlate spectrums
        key, data = self.VCSELLSpectrumLoaded
        corr = np.zeros(len(key))
        for i, sp in enumerate(data):
            try:
                p = stats.pearsonr(spectrumSpline, sp)
                corr[i] = p.statistic
            except:
                corr[i] = 0

        self.vcsellCorrPlot.clear()
        lineCorr = self.vcsellCorrPlot.plot(key[:,0], corr, symbol='o')
        lineCorr.setSymbolSize(5)
        maxIndex = corr.argmax()
        error = key[maxIndex,0] - self.doubleSpinBox_setVCSELL.value()
        il = pg.InfiniteLine(key[maxIndex,0])
        self.vcsellCorrPlot.addItem(il)
        self.label_LaserError.setText(f"{error:.2f}")

        if self.checkBox_VCSELLStab.isChecked() and self.esp32.box.writable():

            self.VCSELLOut.append(self.doubleSpinBox_stabVCSELLOut.value())
            self.VCSELLTimestamp.append(time.time())
            t = np.array(self.VCSELLTimestamp)
            t = t[0] - t
            self.vcsellOutPlot.clear()
            self.vcsellOutPlot.plot(t, self.VCSELLOut)

            integral = self.doubleSpinBox_StabVCSELL_I.value() * error/1e5
            setval = self.doubleSpinBox_stabVCSELLOut.value() - integral
            self.doubleSpinBox_stabVCSELLOut.setValue(setval)

        else:
            self.doubleSpinBox_stabVCSELLOut.setReadOnly(False)


    def stabilizeProbe(self):

        self.label_ProbePowerValue.setText(f"{(1e3 * (self.ProbePower)):.2f} mV")
        error = self.ProbePower - self.doubleSpinBox_setProbePowerValue.value()
        self.label_ProbeError.setText(f"{(1e3 * error):.2f} mV")

        if self.checkBox_StabProbePower.isChecked() and self.esp32.box.writable():
            # make the power stable!
            self.doubleSpinBox_stabProbePowerOut.setReadOnly(True)
            I = self.doubleSpinBox_setProbePowerI.value()
            if np.abs(error) > 0.03:
                I = np.abs(I*(error/0.03))
            i = I * error/1e3
            # p = error * self.doubleSpinBox_setProbePowerP.value()
            v = self.doubleSpinBox_stabProbePowerOut.value()
            sgn = 1 if self.checkBox_ProbeStabInvertPID.isChecked() else -1
            out=v+sgn*i
            self.doubleSpinBox_stabProbePowerOut.setValue(out)
            # ChangeValue event will trigger output update
            self.probeStabError.append(error)
            self.probeStabOut.append(out)
            self.probeStabTimestamp.append(time.time())

            if self.tabWidget.currentIndex() == 3:
                self.plotProbePowerStab()

        else:
            self.doubleSpinBox_stabProbePowerOut.setReadOnly(False)
        try:
            while self.esp32.box.in_waiting > 0:
                line=self.esp32.readLine()
                if not line.strip() == '':
                    self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font color=pink>esp32: {line}</font>")
        except Exception as e:
            print(f"func:stabilizeProbe: {e}")
            self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font color=red>unable to receive data</font>")

    def plotProbePowerStab(self):

        t = np.array(self.probeStabTimestamp)
        t = t[0]-t
        self.errorProbeStabPlot.clear()
        self.errorProbeStabPlot.plot(t, np.array(self.probeStabError))
        #setLabel('bottom', "time (ms)")
        self.errorProbeStabPlot.setLabel('left', "error (V)")


        self.outProbeStabPlot.clear()
        self.outProbeStabPlot.plot(t, np.array(self.probeStabOut))
        self.outProbeStabPlot.setLabel('left', "out (V)")
        self.outProbeStabPlot.setLabel('bottom', "time (s)")  # out is in bottom



    def plotSCPMonitor(self):

        if isinstance(self.SCPData, bool):
            return
        samples = len(self.SCPData[0])
        if samples < 10:
            return
        sr = self.scp.scp.sample_rate
        t = np.linspace(0, 1000 * samples / sr, samples, endpoint=False)
        # print(self.__dict__.get("monitorPlotCH1"))

        plots = [self.__dict__.get("monitorPlotCH"+str(i+1)) for i in range(self.scp.channels)]
        """plots = [self.monitorPlotCH1,
                 self.monitorPlotCH2,
                 self.monitorPlotCH3,
                 self.monitorPlotCH4]"""
        for i in range(self.scp.channels):
            plots[i].clear()
            plots[i].setLabel('bottom', "time (ms)")
            plots[i].setLabel('left', f"CH{i+1} (V)")
            plots[i].plot(t, self.SCPData[i])

    def scpSet(self):

        self.comboBox_CH1Range.setCurrentIndex(self.comboBox_M_CH1Range.currentIndex())
        self.comboBox_CH2Range.setCurrentIndex(self.comboBox_M_CH2Range.currentIndex())
        if self.radioButton_M_CH1AC.isChecked() != self.radioButton_CH1AC.isChecked():
            self.radioButton_CH1AC.toggle()
        if self.radioButton_M_CH2AC.isChecked() != self.radioButton_CH2AC.isChecked():
            self.radioButton_CH2AC.toggle()

        status = self.scp.set(mode=self.getSCPmode(),
                            sample_rate=self.getSampleRate(),
                            record_length=int(self.doubleSpinBox_Samples.value()),
                            CH_ranges=[
                                float(self.comboBox_M_CH1Range.currentText()),
                                float(self.comboBox_M_CH2Range.currentText()),
                                float(self.comboBox_M_CH3Range.currentText()),
                                float(self.comboBox_M_CH4Range.currentText())
                            ],
                            CH_couplings=[
                                self.getCH1coupling(),
                                self.getCH2coupling(),
                                self.getCH3coupling(),
                                self.getCH4coupling()
                            ],
                            trigger_source=self.comboBox_trigger.currentText()
                            )
        if not status:
            #self.statusbar.showMessage("The oscilloscope is not controllable!", 2000)
            #print("The oscilloscope is not controllable!")
            pass
        return status

    def getCH1coupling(self):
        if self.radioButton_M_CH1DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getCH2coupling(self):
        if self.radioButton_M_CH2DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getCH3coupling(self):
        if self.radioButton_M_CH3DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getCH4coupling(self):
        if self.radioButton_M_CH4DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getSCPmode(self):
        if self.radioButton_modeBlock.isChecked():
            return "block"
        else:
            return "stream"

    def getSampleRate(self):
        return self.scp.srs.get(self.comboBox_SampleRate.currentText(), 3125000)

    """ Worker signal functions """

    def res(self, res):
        pass

    def fini(self):
        pass

    def prog(self, n):
        pass

    def boot(self):
        # Execute
        print("Boot SCP")
        self.threadpool.start(self.theWorkerBlocks)

    def setCH_1_2(self):
        # print("setCH_1_2")
        self.comboBox_M_CH1Range.setCurrentIndex(self.comboBox_CH1Range.currentIndex())
        self.comboBox_M_CH2Range.setCurrentIndex(self.comboBox_CH2Range.currentIndex())
        if self.radioButton_CH1AC.isChecked() != self.radioButton_M_CH1AC.isChecked():
            self.radioButton_M_CH1AC.toggle()
        if self.radioButton_CH2AC.isChecked() != self.radioButton_M_CH2AC.isChecked():
            self.radioButton_M_CH2AC.toggle()

    def connectElementTo(self, el, function):
        try:  # dropbox
            el.currentIndexChanged.connect(function)
            return
        except:
            pass
        try:  # input text
            el.valueChanged.connect(function)
            return
        except:
            pass
        try:  # radio buttons
            el.toggled.connect(function)
            return
        except:
            pass
        raise Exception(f"Sorry, {el} not connected with {function}")

    def tabChanged(self):
        if self.tabWidget.currentIndex() == 1:
            print("FIT data set!")
            if self.scp.scp is None:
                n = cr.white_noise(.01, 3125000, 312500, mu=0)
                self.dataSCPtoFITtab = [n, n]
            else:
                self.dataSCPtoFITtab = self.SCPData
            self.fitUISet()

    def fitUISet(self):
        if self.tabWidget.currentIndex() == 1:
            print("FIT time!")
            # set initial parameters

            self.doubleSpinBox_FilterStart_ms.setValue(self.doubleSpinBox_PumpTime_ms.value())
            self.doubleSpinBox_FilterStop_ms.setValue(self.doubleSpinBox_TotalTime_ms.value())
            fitStart = float(self.doubleSpinBox_FilterStart_ms.value()) + 5
            self.doubleSpinBox_FITStart_ms.setValue(fitStart)
            fitStop = float(self.doubleSpinBox_FilterStop_ms.value()) - 5
            self.doubleSpinBox_FITStop_ms.setValue(fitStop)
            self.doubleSpinBox_FIT_f0.setValue(self.doubleSpinBox_Frequency_Hz.value())
            if self.scp.scp is None:
                self.FITSampleRate = 3125000
            else:
                self.FITSampleRate = self.scp.scp.sample_rate

            r = (self.doubleSpinBox_FIT_f0.value() + 500, self.doubleSpinBox_FIT_f0.value() + 1500)
            self.FFTdataPlotFIT_lr.setRegion(r)
            self.FFTFilteredDataPlotFIT_lr.setRegion(r)

            self.fit()

    # The fit function must be static
    @staticmethod
    def FITfunc(x, freq, a, b, gamma, dc):
        return (a * np.sin(2 * np.pi * freq * x) + b * np.cos(2 * np.pi * freq * x)) * np.exp(-gamma * x) + dc

    """Plot, fit, filter, analyse..."""

    def fit(self):

        if self.radioButton_FITSource_CH1.isChecked():
            self.dataFIT = self.dataSCPtoFITtab[0]
        else:
            self.dataFIT = self.dataSCPtoFITtab[1]
        totalTime_ms = float(self.doubleSpinBox_FITStop_ms.value())
        t = np.linspace(0, totalTime_ms, len(self.dataFIT), endpoint=False)

        self.dataPlotFIT.clear()
        self.dataPlotFIT.plot(t/1000, self.dataFIT)
        self.dataPlotFIT.setLabel('bottom', "time", units='s')
        self.dataPlotFIT.setLabel('left', "S", units='V')

        # cut the data

        nStartUnfiltered = int((self.doubleSpinBox_FilterStart_ms.value() * self.FITSampleRate) / 1000)
        nStopUnfiltered = int((self.doubleSpinBox_FilterStop_ms.value() * self.FITSampleRate) / 1000)
        self.unFilteredDataFit = self.dataFIT[nStartUnfiltered: nStopUnfiltered]

        self.unFilteredDataPlotFIT.clear()
        self.unFilteredDataPlotFIT.plot(t[nStartUnfiltered:nStopUnfiltered]/1000, self.unFilteredDataFit)
        self.unFilteredDataPlotFIT.setLabel('bottom', "time", units="s")
        self.unFilteredDataPlotFIT.setLabel('left', "UnFiltered", units='V')


        # filter the data
        detrend = signal.detrend(self.unFilteredDataFit, type='constant')
        decimated = detrend
        for d in self.decimationArr:
            decimated = signal.decimate(decimated, d, ftype='fir')
        """
        decimated = signal.decimate(detrend, 5, ftype='fir')  # reduce sample rate 5x
        # print(len(self.unFilteredDataFit))
        # print(len(decimated), len(self.unFilteredDataFit)/len(decimated))
        decimated = signal.decimate(decimated, 4, ftype='fir')  # reduce sample rate 4x
        # print(len(decimated), len(self.unFilteredDataFit) / len(decimated))
        """

        # filter the data
        ciFilter = self.comboBox_FilterType.currentIndex()
        filRange = 1e3
        filterLength = 601  # must be odd number!!!!!!!!!!!!!!!!!!!!
        pass_zero = False
        if ciFilter == 0:  # High pass from 1k
            filRange = 10e3
            pass_zero = False
        elif ciFilter == 1:  # Band pass 1-12k
            filRange = 1e3, 12e3
            pass_zero = False
        elif ciFilter == 2:  # Band pass 8-22k
            filRange = 8e3, 22e3
            pass_zero = False
        elif ciFilter == 3:  # Band pass 18-32k
            filRange = 18e3, 32e3
            pass_zero = False
        elif ciFilter == 4:  # Low pass up to 12k
            filRange = 12e3
            pass_zero = True

        # drop = int((filterLength - 1) / 2)
        fltr = signal.firwin(filterLength, filRange, pass_zero=pass_zero, fs=self.FITSampleRate / np.prod(self.decimationArr))

        filtered = signal.convolve(decimated - np.mean(decimated), fltr, mode='valid')
        self.filteredDataFIT = signal.detrend(filtered, type='constant')
        n = len(self.filteredDataFIT)
        tf = np.linspace(0, (n * np.prod(self.decimationArr)) / self.FITSampleRate, n, endpoint=False)

        # fit of the data
        # curve_fit

        p0 = [self.doubleSpinBox_FIT_f0.value(),
              self.doubleSpinBox_FIT_A.value(),
              self.doubleSpinBox_FIT_B.value(),
              2 * np.pi * self.doubleSpinBox_FIT_Gamma.value(),  # from Hz to rad^-1
              self.doubleSpinBox_FIT_DC.value()]
        popt, pcov = curve_fit(self.FITfunc, tf, self.filteredDataFIT, p0=p0)
        self.lastFIT = [popt, pcov]
        print("popt = ", popt)
        plainText = "f = {:.4f} Hz\n".format(popt[0])  # +str(popt[0]) + "\n"
        plainText += "A = {:.2e} V\n".format(popt[1])
        plainText += "B = {:.2e} V\n".format(popt[2])
        plainText += "gamma = {:.2e} Hz\n".format(popt[3]/(2 * np.pi))
        plainText += "dc = {:.2e} V\n".format(popt[4])
        plainText += "mean = {:.2e} V\n".format(
            np.mean(self.unFilteredDataFit))
        self.plainTextEdit_FITResults.setPlainText(plainText)

        fitCurve = self.FITfunc(tf, *popt)
        self.FITdataPlotFIT.clear()
        self.FITdataPlotFIT.plot(tf, self.filteredDataFIT, pen=self.penX)
        self.FITdataPlotFIT.plot(tf, fitCurve, pen=self.penZ)
        self.FITdataPlotFIT.setLabel('bottom', "time", units="s")
        self.FITdataPlotFIT.setLabel('left', "FIT", units='V')

        self.ResidualsDataPlotFIT.clear()
        self.ResidualsDataPlotFIT.plot(tf, self.filteredDataFIT - fitCurve, pen=self.penY)
        self.ResidualsDataPlotFIT.setLabel('bottom', "time", units="s")
        self.ResidualsDataPlotFIT.setLabel('left', "Residuals", units="V")

        """ scipy.signal.periodogram(x, fs=1.0, window='boxcar', nfft=None,
         detrend='constant', return_onesided=True, 
         scaling='density', axis=- 1)
        """

        mean = np.mean(self.unFilteredDataFit)
        sh_V = np.sqrt(2 * 1.6e-19 * (mean + self.doubleSpinBox_SignalOffset.value())/ self.doubleSpinBox_TransImp_Gain.value()) * self.doubleSpinBox_TransImp_Gain.value()  # shot noise spectral noise density
        print(f"shot Noise for FFT {sh_V} (V/sqrt(Hz))")


        vsqrtHztext = "V/&radic;<span style='text-decoration:overline;'>&nbsp;Hz&nbsp;</span>"
        f, pxx = signal.periodogram(self.unFilteredDataFit, self.FITSampleRate, window='hann')
        self.FITlastFFT = f, pxx
        self.FFTdataPlotFIT.clear()
        self.FFTdataPlotFIT.setLogMode(y=True)
        self.FFTdataPlotFIT.plot(f, np.sqrt(pxx))
        self.FFTdataPlotFIT.plot([0, np.max(f)], [sh_V, sh_V], pen=self.penY)
        self.FFTdataPlotFIT.addItem(self.FFTdataPlotFIT_lr)
        self.FFTdataPlotFIT.setLabel('bottom', "Frequency", units="Hz")
        self.FFTdataPlotFIT.setLabel('left', "PSD", units=vsqrtHztext)


        f, pxx = signal.periodogram(self.filteredDataFIT, self.FITSampleRate/ np.prod(self.decimationArr), window='hann')

        self.FFTFilteredDataPlotFIT.clear()
        self.FFTFilteredDataPlotFIT.setLogMode(y=True)
        self.FFTFilteredDataPlotFIT.plot(f, np.sqrt(pxx))
        self.FFTFilteredDataPlotFIT.plot([0, np.max(f)], [sh_V, sh_V], pen=self.penY)
        self.FFTFilteredDataPlotFIT.setLabel('bottom', "Frequency", units="Hz")
        self.FFTFilteredDataPlotFIT.setLabel('left', "PSD filtered", units=vsqrtHztext)
        self.FFTFilteredDataPlotFIT.addItem(self.FFTFilteredDataPlotFIT_lr)

        self.updateCR()  # update also error estimate calc

    def updateCRRange(self):
        r = self.FFTdataPlotFIT_lr.getRegion()
        self.FFTFilteredDataPlotFIT_lr.setRegion(r)

    def copyFITtoInit(self):
        toBlock = [self.doubleSpinBox_FIT_f0,
                   self.doubleSpinBox_FIT_A,
                   self.doubleSpinBox_FIT_B,
                   self.doubleSpinBox_FIT_Gamma
                   ]
        for o in toBlock:
            o.blockSignals(True)
        popt = self.lastFIT[0]
        self.doubleSpinBox_FIT_f0.setValue(popt[0])
        self.doubleSpinBox_FIT_A.setValue(popt[1])
        self.doubleSpinBox_FIT_B.setValue(popt[2])
        self.doubleSpinBox_FIT_Gamma.setValue(popt[3])
        self.doubleSpinBox_FIT_DC.setValue(popt[4])

        self.doubleSpinBox_Frequency_Hz.setValue(popt[0])

        for o in toBlock:
            o.blockSignals(False)

    # set save records number
    def saveRecordsChanged(self):
        self.countRemainingToSave = int(self.doubleSpinBox_RecordsToSave.value())

    def stabProbePowerOutChanged(self):
        # if stabilization is ON do nothing
        self.MAX11300out(self.doubleSpinBox_stabProbePowerOut.value(), ch=0)

    def stabVCSELLOutChanged(self):
        self.MAX11300out(self.doubleSpinBox_stabVCSELLOut.value(), ch=1)

    def updateCR(self):
        start, stop = self.FFTFilteredDataPlotFIT_lr.getRegion()
        self.FFTdataPlotFIT_lr.setRegion([start, stop])
        print(start, stop)

        f, pxx = self.FITlastFFT
        fSel = (f > start) & (f < stop)
        pxxSelVals = pxx[fSel]
        NSD = np.sqrt(np.mean(pxxSelVals))
        print("Noise:", NSD, " V/sqrt(Hz)")
        mean = np.mean(self.unFilteredDataFit)
        sh = np.sqrt(2 * 1.6e-19 * (mean + self.doubleSpinBox_SignalOffset.value()) / self.doubleSpinBox_TransImp_Gain.value())  # shot noise spectral noise density
        sh_V = sh * self.doubleSpinBox_TransImp_Gain.value()


        popt, pcov = self.lastFIT
        A = np.sqrt(popt[1]**2 + popt[2]**2)
        T2 = 1./popt[3]
        scaleToSens = np.sqrt(500/self.doubleSpinBox_TotalTime_ms.value())

        T = (self.doubleSpinBox_FilterStop_ms.value() - self.doubleSpinBox_FilterStart_ms.value())/1e3
        N = T * self.FITSampleRate
        CramerRao, C = cr.cr(A, NSD, T, N, T2=T2)
        print("cr = {:.2e}".format(CramerRao))
        text = "Freq. range = [{:.2f}, {:.2f}] Hz\n".format(start, stop)
        text += "R = {:.2e} V\n".format(A)
        text += " NSD = {:.3e} V/sqrt(Hz)\n".format(NSD)
        text += f"shSD = {sh_V:.3e} V/sqrt(Hz)\n"
        text += "C = {:.3e}\n".format(C)
        text += "cr = {:.1e} Hz\n".format(CramerRao)
        #text += "dB(FSP) = {:.1f} fT\n".format(CramerRao * 1e6/3.5)
        #text += "dB(FAP) = {:.1f} fT\n".format(CramerRao * 1e6/7.0)
        text += f"dB(FSP) = {(CramerRao * 1e6 / 3.5):.1f} fT  sens = {(CramerRao * 1e6 / (scaleToSens* 3.5)):.1f} ft/sqrt(Hz) \n"
        text += f"dB(FAP) = {(CramerRao * 1e6 / 7.0):.1f} fT sens = {(CramerRao * 1e6 / (scaleToSens* 7)):.1f} ft/sqrt(Hz) \n"



        print(f"Shot noise: {sh} A/sqrt(Hz)")
        print(f"Shot noise: {sh * self.doubleSpinBox_TransImp_Gain.value()} V/sqrt(Hz)")
        CramerRaoSH, C = cr.cr(A, sh * self.doubleSpinBox_TransImp_Gain.value(), T, N, T2=T2)
        text += f"\nIn shotnoise limit with {self.doubleSpinBox_TransImp_Gain.value()} V/A gain:\n"
        text += f"dB(FSP) = {(CramerRaoSH * 1e6 / 3.5):.1f} fT sens = {(CramerRaoSH * 1e6 / (scaleToSens* 3.5)):.1f} ft/sqrt(Hz)\n"
        text += f"dB(FAP) = {(CramerRaoSH * 1e6 / 7.0):.1f} fT sens = {(CramerRaoSH * 1e6 / (scaleToSens* 7)):.1f} ft/sqrt(Hz)\n"



        self.plainTextEdit_SensitivityFFT.setPlainText(text)

    def selectFilename(self, use='open', type="All files (*)"):
        if use=='open':
            return QtWidgets.QFileDialog.getOpenFileName(None, 'Select settings file',"",type)
        else:
            return QtWidgets.QFileDialog.getSaveFileName(None, 'Select settings file',"",type)

    def selectFolder(self):
        folderpath = QtWidgets.QFileDialog.getExistingDirectory(None, 'Select Folder')
        self.lineEdit_FolderName.setText(folderpath+"\\")

    """
    import shutil

    total, used, free = shutil.disk_usage("/")
    
    print("Total: %d GiB" % (total // (2**30)))
    print("Used: %d GiB" % (used // (2**30)))
    print("Free: %d GiB" % (free // (2**30)))
"""
    def showDiskSpace(self):
        GB = 2**30
        total, used, free = shutil.disk_usage(self.lineEdit_FolderName.text())
        self.label_DiskSpace.setText(f"Free space: {free/GB:.2f} GB")

        # msg.buttonClicked.connect(self.popup_button)
    def genStartStop(self):
        # self.okButton_GeneratorStart.clicked.connect(self.genStartStop)
        if self.gen.gen.output_enable: # output_on
            self.gen.stop()
        else:
            self.arbSet()

    def arbSet(self):
        arbObj = arbcalc(totalTime=float(self.doubleSpinBox_TotalTime_ms.value()) / 1000,
                         pumpTime=float(self.doubleSpinBox_PumpTime_ms.value()) / 1000,
                         dutyCycle=float(self.doubleSpinBox_DutyCycle.value()),
                         probeLevel=float(self.doubleSpinBox_ProbeLevel.value()),
                         pumpLevel=float(self.doubleSpinBox_PumpLevel.value()),
                         zeroLevel=float(self.doubleSpinBox_ZeroLevel.value()),
                         pumpFrequency=float(self.doubleSpinBox_Frequency_Hz.value()),
                         noPoints=int(self.doubleSpinBox_Points.value()),
                         expAmplitude=float(self.doubleSpinBox_ExpAmplitude.value()),
                         expRelaxation=float(self.doubleSpinBox_ExpRelaxation.value())
                         )
        arb = arbObj.arb()
        t, y = arb
        if not self.gen.arbLoad(y,
                                amplitude=np.max(np.abs(y)),
                                frequency=1000 / float(self.doubleSpinBox_TotalTime_ms.value())):
            self.statusbar.showMessage("The Generator is not accesible.", 2000)

        self.plotArb(t, y)
        self.gen.start()

    """
    Stop the app, save settings etc.
    """
    def onClose(self):
        print("Time to close...")
        self.timerPlotSCP.stop()
        self.gen.stop()
        self.scpWorkerStop(self.theWorkerBlocks)

        # stop save
        try:
            if self.checkBox_SaveData.isChecked():
                self.checkBox_SaveData.setChecked(False)
                self.threadpool.stop(self.theWorkerSave)
        except Exception as e:
            print(e)

        # save settings
        self.saveSettings()

        print("|End of onClose!")

    def saveSettings(self, file='settings.zg.npy'):
        # print(f"{vars(self)=}")

        settingsToSave = []
        checkBoxesToSave=["checkBox_ProbeStabInvertPID", "checkBox_VCSELLStabInvertPID"]
        for key, v in self.__dict__.items():
            o = self.__getattribute__(key)
            """
            QtWidgets.QRadioButton
            QtWidgets.QComboBox
            QtWidgets.QDoubleSpinBox
            QtWidgets.QCheckBox - not important
            QtWidgets.QLineEdit
            """
            # print(o.__class__)
            if o.__class__ == QtWidgets.QComboBox:
                # print(f"{o=}  -> {o.currentIndex()}")
                settingsToSave.append([key, o.currentIndex(), 'QtWidgets.QComboBox'])

            if o.__class__ == QtWidgets.QRadioButton:
                # print(f"{o=}  -> {o.isChecked()}")
                settingsToSave.append([key, o.isChecked(), 'QtWidgets.QRadioButton'])

            if o.__class__ == QtWidgets.QCheckBox and key in checkBoxesToSave:
                #print(f"{o=}  -> {o.isChecked()}, {key=}")
                settingsToSave.append([key, o.isChecked(), 'QtWidgets.QCheckBox'])

            if o.__class__ == QtWidgets.QDoubleSpinBox:
                # print(f"{o=}  -> {o.value()}")
                settingsToSave.append([key, o.value(), 'QtWidgets.QDoubleSpinBox'])
            if o.__class__ == QtWidgets.QLineEdit:
                # print(f"{o=}  -> {o.text()}")
                settingsToSave.append([key, o.text(), 'QtWidgets.QLineEdit'])

            # print(settingsToSave)
        np.save(file, settingsToSave)
        print(f"Settings saved into {file}.")
        """
        # on close is called multiple times by sys.exit(app.exec_())
        for line in traceback.format_stack():
            print(line.strip())
        
        """

    def loadSettings(self, file='settings.zg.npy'):

        # load settings
        try:
            settings = np.load(file)
            # print(settings)
            for setting in settings:
                o = self.__getattribute__(setting[0])
                if setting[2] == "QtWidgets.QDoubleSpinBox":
                    o.setValue(float(setting[1]))
                if setting[2] == "QtWidgets.QComboBox":
                    o.setCurrentIndex(int(setting[1]))
                # if setting[2] == "QtWidgets.QRadioButton":
                #    o.setChecked(setting[1] in ['true', 'True'])
                if setting[2] == "QtWidgets.QCheckBox":
                    o.setChecked(setting[1] in ['true', 'True'])
                if setting[2] == "QtWidgets.QLineEdit":
                    o.setText(setting[1])
            print("Settings applied!")
        except Exception as e:
            print(f"Load settings exception: {e.__str__()}")

    def actionSave_settings_handler(self):
        file, type = self.selectFilename(use='save', type="Settings file (*.zg.npy)")
        print("actionSave_settings_handler file=", file)
        self.saveSettings(file=file)

    def actionLoad_settings_handler(self):
        file, type = self.selectFilename(use='open',type="Settings file (*.zg.npy)")
        #print(file)
        self.loadSettings(file=file)

    def updateConnectionInfo(self):
        self.label_SerialPortName.setText(self.esp32.port)
        self.label_SerialPortBaud.setText(str(self.esp32.baud))

    def saveVCSELLSpectrum(self):
        directory = "./spectrums/" + self.lineEdit_SpectrumLabel.text()
        try:
            os.mkdir(directory)
            self.refreshSpectrumFolderCombo()
        except Exception as e:
            print(f"{e}")
        if os.path.exists(directory):
            # directory exists - save
            spectrum = self.vcsellSpectrumPlot.listDataItems()[0].yData
            delta = self.doubleSpinBox_PumpLevel.value() - self.doubleSpinBox_ZeroLevel.value()

            fileName = f"{directory}/{self.doubleSpinBox_stabSpectrumSaveNo.value():.0f}_{self.doubleSpinBox_stabVCSELLOut.value():.4f}_{delta:.4f}.npy"
            np.save(fileName, spectrum)
        else:
            print(f"Directory {directory} is not found")
            return False



    def loadVCSELLSpectrum(self):

        directory = "./spectrums/" + self.comboBox_SelectVCSELLSpectrum.currentText()+"/"
        fileNames = glob.glob(directory+"*.npy")
        data = np.zeros((len(fileNames), 140))
        key = np.zeros((len(fileNames), 3))

        for i, file in enumerate(fileNames):
            basename = os.path.basename(file)[:-4]
            fs = basename.split("_")
            key[i, 0], key[i, 1], key[i, 2] = int(fs[0]), float(fs[1]), float(fs[2])
            data[i] = np.load(file)

        sorted_key = key[:, 1].argsort()
        key = key[sorted_key]
        data = data[sorted_key]
        
        # chk if zero - pump difference is OK
        if self.doubleSpinBox_PumpLevel.value() - self.doubleSpinBox_ZeroLevel.value() != key[0,2]:
            print("Need to adjust pump level")
            self.doubleSpinBox_PumpLevel.setValue(key[0,2] + self.doubleSpinBox_ZeroLevel.value())

        self.VCSELLSpectrumLoaded = key, data

    def MAX11300out(self, value, v_range=[-5, 5], ch=0):
        if value < v_range[0] or value > v_range[1]:
            print(f"value {value} out of range {v_range}")
            self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font=red>value {value} out of range {v_range}</font>")
        r = v_range[1] - v_range[0]
        step = r/2**12
        binout = int((value - v_range[0]) / step)
        self.esp32.sendToBox(f"set {ch} {binout}")
        self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font=white>set {ch} {binout} -> {value=}</font>")


    def ScanDetuningVoltageGenerate(self):
        scan_detuning_voltages = np.linspace(self.doubleSpinBox_scan_minOutV.value(), self.doubleSpinBox_scan_maxOutV.value(), int(self.doubleSpinBox_VScanIntervals.value()))
        return scan_detuning_voltages
    def ScanAmplitudesGenerate(self):
        scan_pump_amplitudes = np.linspace(self.doubleSpinBox_scan_minAmplitude.value(), self.doubleSpinBox_scan_maxAmplitude.value(),int( self.doubleSpinBox_AmplitudeScanIntervals.value()))
        return scan_pump_amplitudes
    def ScanValuesGenerate(self):

        if self.checkBox_VRangeScan.isChecked():
            scan_detuning_voltages = self.ScanDetuningVoltageGenerate()
        else:
            scan_detuning_voltages=np.array([self.doubleSpinBox_stabVCSELLOut.value()])

        if self.checkBox_AmplitudeRangeScan.isChecked():
            scan_pump_amplitudes = self.ScanAmplitudesGenerate()
        else:
            scan_pump_amplitudes = np.array([self.doubleSpinBox_PumpLevel.value()-self.doubleSpinBox_ZeroLevel.value()])

        mean_pump = np.mean([self.doubleSpinBox_PumpLevel.value(), self.doubleSpinBox_ZeroLevel.value()])

        scan_pump = mean_pump + scan_pump_amplitudes / 2
        scan_zero = mean_pump - scan_pump_amplitudes / 2

        scan_values=[]
        for sa in scan_detuning_voltages:
            for sp in zip(scan_pump, scan_zero):
                scan_values.append([sa,sp[0],sp[1]])
        print("Novo")
        print (scan_values)

        return scan_values

    def rangeScanStartStop(self):
        print("rangeScanStartStop")

        if not self.scanRunning:
            # Open file dialog to choose folder
            save_folder_path = QtWidgets.QFileDialog.getExistingDirectory(None, "Select Folder to Save Files")

            # Check if folder path is empty (user canceled the dialog)
            if not save_folder_path:
                return

            # Store the folder path as a class attribute for later use
            self.save_folder_path = save_folder_path

            # Create the folder if it doesn't exist
            if not os.path.exists(self.save_folder_path):
                os.makedirs(self.save_folder_path)

            self.scanRunning = True
            self.scanIndex=0
            self.okButton_RangeScanStart.setText("Stop Scan")
            self.checkBox_VCSELLStab.setChecked(False)  # Uncheck checkbox

            # Generate scan values and initialize results
            self.scan_values = self.ScanValuesGenerate()
            self.scan_results = []

            # Set scanning parameters
            self.scanSet()
        else:
            # Stop the scan
            self.scanRunning = False
            self.timerScanSaveDelay.stop()

            # Append log message
            self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font color='red'>Scan stopped!</font>")

            # Change button text back to 'Start Scan'
            self.okButton_RangeScanStart.setText("Start Scan")

            return self.save_folder_path

    def scanSet(self):
        print("on_ScanSaveData")
        if not self.scanRunning:
            return

        # set new values
        stab_V, pump, zero = self.scan_values[self.scanIndex]
        self.doubleSpinBox_PumpLevel.blockSignals(True)
        self.doubleSpinBox_ZeroLevel.blockSignals(True)
        self.doubleSpinBox_PumpLevel.setValue(pump)
        self.doubleSpinBox_ZeroLevel.setValue(zero)
        self.doubleSpinBox_stabVCSELLOut.setValue(stab_V)
        self.doubleSpinBox_PumpLevel.blockSignals(False)
        self.doubleSpinBox_ZeroLevel.blockSignals(False)
        self.arbSet()

        # start timer to do wait before measurement
        self.timerScanSaveDelay.singleShot(int(self.doubleSpinBox_ScanWaitTime.value() * 1000), self.scanSave)

    def scanSave(self):
        # Collect data
        self.plotSCP()  # Ensure amplitude is updated
        scan_params = self.scan_values[self.scanIndex]
        scan_params.append(self.amplitude * 1e-3)

        # Ensure SCP data is available
        if isinstance(self.SCPData, bool) or not self.SCPData:
            self.statusbar.showMessage("No SCP data available for saving!", 2000)
            return

        # Use the saved folder path from rangeScanStartStop
        if not hasattr(self, 'save_folder_path'):
            self.statusbar.showMessage("No folder selected for saving files.", 2000)
            return

        folder_path = self.save_folder_path  # Use the saved folder path

        # Ensure the folder exists, or create it
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)

        # Generate a unique file name based on scan parameters
        stab_V, pump, zero, amplitude = scan_params
        file_name = f"VStab_{stab_V:.5f}_Pump_{pump:.2f}_Zero_{zero:.2f}_Amp_{amplitude*1000:.7f}.npy"
        file_path = os.path.join(folder_path, file_name)

        try:
            # Combine scan parameters and SCP data
            data_to_save = {
                "scan_params": scan_params,
                "scp_data": self.SCPData
            }

            # Save the combined data
            np.save(file_path, data_to_save)
            self.statusbar.showMessage(f"Saved: {file_name}", 2000)
        except Exception as e:
            self.statusbar.showMessage(f"Error saving file: {e}", 2000)


        try:
            self.saveSettings(file=os.path.join(folder_path,
                                                f"VStab_{stab_V:.5f}_Pump_{pump:.2f}_Zero_{zero:.2f}_Amp_{amplitude*1000:.7f}_settings.npy"))
            print(f"Settings saved for scan: {file_name}")
        except Exception as e:
            print(f"Error saving settings file: {e}")
            return
        # Move to the next scan
        self.scanIndex += 1
        print(f"Remaining scans: {len(self.scan_values) - self.scanIndex}, Progress: {self.scanIndex}/{len(self.scan_values)}")
        if self.scanIndex > len(self.scan_values) - 1:
            self.plainTextEdit_ESP32SerialLog.appendHtml(f"<font color='red'>Scan ended!</font>")
            print("Scan ended!")
            self.okButton_RangeScanStart.setText("Start Scan")
            self.scanRunning = False
            return

        # Set up the next scan
        self.scanSet()

    def saveScanResultsToFile(self):
        if not self.scan_results:
            self.statusbar.showMessage("No scan results to save!", 2000)
            return

        # Open file dialog to select save location
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            None, "Save Scan Results", "", "Numpy Files (*.npy);;All Files (*)"
        )
        if file_path:
            try:
                # Save the scan results to the selected file
                np.save(file_path, np.array(self.scan_results))
                self.statusbar.showMessage(f"Scan results saved to {file_path}", 2000)
            except Exception as e:
                self.statusbar.showMessage(f"Error saving file: {e}", 2000)

    def trigger_changed(self):
        self.scpSet()

##############################################################################################
#
#                    Start the app
#
##############################################################################################

def main():
    app = QtWidgets.QApplication(sys.argv)
    app.setStyleSheet(qdarkgraystyle.load_stylesheet())


    # not working, icon set in te Qt Designer
    # app_icon = QtGui.QIcon()
    # app_icon.addFile('images/ZG-Speach-Bubble-16x16-icon.png', QtCore.QSize(16, 16))
    # app_icon.addFile('images/ZG-Speach-Bubble-24x24-icon.png', QtCore.QSize(24, 24))
    # app_icon.addFile('images/ZG-Speach-Bubble-32x32-icon.png', QtCore.QSize(32, 32))
    # app_icon.addFile('images/ZG-Speach-Bubble-48x48-icon.png', QtCore.QSize(48, 48))
    # app_icon.addFile('images/ZG-Speach-Bubble-256x256-icon.png', QtCore.QSize(256, 256))
    # app.setWindowIcon(app_icon)

    MainWindow = QtWidgets.QMainWindow()
    ui = MyUi()
    app.aboutToQuit.connect(ui.onClose) # close the app handler function
    ui.setupUi(MainWindow)
    MainWindow.showMaximized()

    sys.exit(app.exec_())
    # del MainWindow

if __name__.endswith('__main__'):
    main()