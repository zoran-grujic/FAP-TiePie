#  Copyright (c) 2021.
#  This code has been produced by Zoran D. Grujic and by the knowledge found on The Internet.
#  Please feel free to ask me for permission to use my code in your own projects. It is for your own well fare!
#  pyinstaller --onefile -w app.pyw

# ---------------------------------------------
# to find QtDesigner and pyuic5 files goto
# C:\Users\Zoran\Anaconda3\Library\bin
# C:\Users\Zoran\Anaconda3\Library\bin\pyuic5 gui.ui -o gui.py

import qdarkgraystyle  # https://pypi.org/project/qdarkgraystyle/

from PyQt5.QtCore import QThreadPool
from QtWorker import Worker
import sys
import os
import logging
from PyQt5 import QtCore  # conda install pyqt
from PyQt5 import QtWidgets
import pyqtgraph as pg  # Fast plot package
import numpy as np
from scipy import signal
import time
from datetime import datetime
from scipy.optimize import curve_fit
from arbcalc import arbcalc
from tiepieArb import arbGenerator
from tiepieSCP import oscilloscope

from gui import Ui_MainWindow  # generated by designer, DO NOT EDIT
import libtiepie


# extend Ui_MainWindow class
class MyUi(Ui_MainWindow):
    plotWindow = pg.GraphicsWindow()
    FITplotWindow_Widget = pg.GraphicsWindow()
    timerPlotSCP = QtCore.QTimer()
    timerStart = QtCore.QTimer()
    rePlotInterval_ms = 100
    SCPData = False
    dataFITtab = False

    colorX = (100, 200, 250)
    colorY = (100, 250, 200)
    colorZ = (250, 100, 200)
    penX = pg.mkPen(colorX, width=2, style=QtCore.Qt.SolidLine)
    penY = pg.mkPen(colorY, width=2, style=QtCore.Qt.SolidLine)
    penZ = pg.mkPen(colorZ, width=2, style=QtCore.Qt.SolidLine)

    """Initialize the app"""

    def __init__(self):
        super(MyUi, self).__init__()

        self.dialogs = list()

        self.gen = arbGenerator()
        self.scp = oscilloscope()

        self.threadpool = QThreadPool()
        self.theWorkerBlocks = Worker(self.getBlocks)  # Any other args, kwargs are passed to the run function
        self.theWorkerSave = Worker(self.SaveData)  # Any other args, kwargs are passed to the run function
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())

        self.timerPlotSCP.setInterval(self.rePlotInterval_ms)
        self.timerPlotSCP.timeout.connect(self.plotSCP)

        self.timerStart.setInterval(1000)
        self.timerStart.timeout.connect(self.boot)

    """
    override function of the parent class to connect actions and buttons
    set user interface
    """

    def setupUi(self, MainWindow):
        super(MyUi, self).setupUi(MainWindow)  # call function of the parent class

        self.okButton_GeneratorStart.clicked.connect(self.genStartStop)
        self.tabWidget.currentChanged.connect(self.tabChanged)

        elements = [self.doubleSpinBox_PumpLevel,
                    self.doubleSpinBox_ProbeLevel,
                    self.doubleSpinBox_ZeroLevel,
                    self.doubleSpinBox_Frequency_Hz,
                    self.doubleSpinBox_TotalTime_ms,
                    self.doubleSpinBox_DutyCycle,
                    self.doubleSpinBox_PumpTime_ms,
                    self.doubleSpinBox_Points
                    ]
        for el in elements:
            el.valueChanged.connect(self.arbSet)

        elements = [self.doubleSpinBox_FilterStart_ms,
                    self.doubleSpinBox_FilterStop_ms,
                    self.doubleSpinBox_FIT_f0,
                    self.doubleSpinBox_FIT_A,
                    self.doubleSpinBox_FIT_B,
                    self.doubleSpinBox_FIT_Gamma,
                    self.doubleSpinBox_FIT_DC
                    ]
        for el in elements:
            el.valueChanged.connect(self.fit)
        self.comboBox_FilterType.currentIndexChanged.connect(self.fitUISet)
        self.radioButton_FITSource_CH1.clicked.connect(self.fitUISet)
        self.radioButton_FITSource_CH2.clicked.connect(self.fitUISet)

        # make plot widget and layout

        containing_layout = self.PlotPlaceholder.parent().layout()
        containing_layout.replaceWidget(self.PlotPlaceholder, self.plotWindow)
        PG_layout = pg.GraphicsLayout()  # make layout for plots

        self.arbPlot = PG_layout.addPlot()
        PG_layout.nextRow()
        self.ch1Plot = PG_layout.addPlot()
        PG_layout.nextRow()
        self.ch2Plot = PG_layout.addPlot()

        self.plotWindow.setCentralItem(PG_layout)  # set layout to the widget

        containing_layout = self.FITPlotPlaceholder.parent().layout()
        containing_layout.replaceWidget(self.FITPlotPlaceholder, self.FITplotWindow_Widget)
        PG_layout_Tab_2 = pg.GraphicsLayout()  # make layout for plots

        self.dataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.unFilteredDataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextRow()
        self.FITdataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.FFTdataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextRow()
        self.ResidualsDataPlotFIT = PG_layout_Tab_2.addPlot()
        PG_layout_Tab_2.nextColumn()
        self.FFTFilteredDataPlotFIT = PG_layout_Tab_2.addPlot()

        self.FITplotWindow_Widget.setCentralItem(PG_layout_Tab_2)

        self.checkBox_SaveData.setStyleSheet("QCheckBox::indicator { width: 70; height: 70;}")

        # Execute
        self.scpWorkerStart(self.theWorkerBlocks)
        self.timerPlotSCP.start()
        # self.genStartStop()

    def scpWorkerStart(self, worker):

        print("Boot SCP")
        self.scpSet()
        try:
            worker.signals.result.connect(self.res)
            worker.signals.finished.connect(self.fini)
            worker.signals.progress.connect(self.prog)

            # Execute
            self.threadpool.start(worker)
            print("Worker read SCP data Started")
        except Exception as e:
            print("scpWorkerStart exception: ", e)

    def scpWorkerStop(self, worker):
        try:
            self.threadpool.stop(worker)
        except Exception as e:
            print("scpWorkerStop exception: ", e)

    def SaveData(self, progress_callback):
        pass

    def saveData(self, data):
        try:
            now = datetime.now()  # current date and time
            date_time = now.strftime("%Y%M%d_%H-%M-%S-%f")
            print("date and time:", date_time)
            fn = "data/" + self.lineEdit_FileNamePrefix.text() + date_time
            np.save(fn, data)
            print("File: ", fn)
            return True
        except Exception as e:
            print("Save data Exception:", e)
        return False

    def getBlocks(self, progress_callback):
        print("Worker here")

        scp = self.scp.scp
        while True:
            if self.radioButton_modeBlock.isChecked():
                # block mode
                if scp.is_running and scp.measure_mode == libtiepie.MM_STREAM:
                    # change from STREAM to BLOCK
                    scp.stop()
                    self.scpSet()
                    scp.start()
                else:
                    self.scpSet()  # set SCP parameters
                    scp.start()
                # Wait for measurement to complete:
                while not scp.is_data_ready:
                    time.sleep(0.01)  # 10 ms delay, to save CPU time

                # Get data:
                self.SCPData = scp.get_data()
                # print("Got SCP data!")
            else:
                # stream mode
                # print("Stream mode")
                if scp.measure_mode == libtiepie.MM_BLOCK:
                    # change from BLOCK to STREAM
                    self.scpSet()
                    scp.start()
                else:
                    if not scp.is_running:
                        scp.start()

                while not scp.is_data_ready:
                    time.sleep(0.01)  # 10 ms delay, to save CPU time

                # Get data:
                self.SCPData = scp.get_data()
                # print("Got SCP data!")
            # print(scp.measure_mode)
            if self.checkBox_SaveData.isChecked():
                self.saveData(self.SCPData)

    def plotArb(self, t, y):

        self.arbPlot.clear()
        self.arbPlot.plot(1000 * t, y)
        self.arbPlot.setLabel('bottom', "time (ms)")
        self.arbPlot.setLabel('left', "S (V)")

        scp = self.scp.scp
        if scp is None or (scp.is_running and scp.measure_mode == libtiepie.MM_STREAM):
            # not controlable
            self.statusbar.showMessage("Oscilloscope and Arb. signal Generator are not controllable in STREAM mode!",
                                       2000)
            return False

        if not self.timerPlotSCP.isActive():
            self.timerPlotSCP.start()

    def getOscData(self):
        self.scpSet()
        self.SCPData = self.scp.getBlock()

        self.plotSCP()

    def plotSCP(self):
        if isinstance(self.SCPData, bool):
            return
        samples = len(self.SCPData[0])
        if samples < 10:
            return
        sr = self.scp.scp.sample_frequency
        t = np.linspace(0, 1000 * samples / sr, samples, endpoint=False)

        self.ch1Plot.clear()
        self.ch2Plot.clear()

        self.ch1Plot.setLabel('bottom', "time (ms)")
        self.ch1Plot.setLabel('left', "CH1 (V)")
        self.ch1Plot.plot(t, self.SCPData[0])

        self.ch2Plot.setLabel('bottom', "time (ms)")
        self.ch2Plot.setLabel('left', "CH2 (V)")
        self.ch2Plot.plot(t, self.SCPData[1])

    def scpSet(self):
        if not self.scp.set(mode=self.getSCPmode(),
                            sample_frequency=self.getSampleRate(),
                            record_length=int(self.doubleSpinBox_Samples.value()),
                            CH1_range=float(self.comboBox_CH1Range.currentText()),
                            CH2_range=float(self.comboBox_CH2Range.currentText()),
                            CH1_coupling=self.getCH1coupling(),
                            CH2_coupling=self.getCH2coupling()
                            ):
            self.statusbar.showMessage("The oscilloscope is not controllable!", 2000)
            print("The oscilloscope is not controllable!")

    def getCH1coupling(self):
        if self.radioButton_CH1DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getCH2coupling(self):
        if self.radioButton_CH2DC.isChecked():
            return "dc"
        else:
            return "ac"

    def getSCPmode(self):
        if self.radioButton_modeBlock.isChecked():
            return "block"
        else:
            return "stream"

    def getSampleRate(self):
        return self.scp.srs.get(self.comboBox_SampleRate.currentText(), 3125000)

    """ Worker signal functions """

    def res(self, res):
        pass

    def fini(self):
        pass

    def prog(self, n):
        pass

    def boot(self):
        # Execute
        print("Boot SCP")
        self.threadpool.start(self.theWorkerBlocks)

    def tabChanged(self):
        if self.tabWidget.currentIndex() == 1:
            print("FIT data set!")
            self.dataSCPtoFITtab = self.SCPData
            self.fitUISet()

    def fitUISet(self):
        if self.tabWidget.currentIndex() == 1:
            print("FIT time!")
            # set initial parameters

            self.doubleSpinBox_FilterStart_ms.setValue(self.doubleSpinBox_PumpTime_ms.value())
            self.doubleSpinBox_FilterStop_ms.setValue(self.doubleSpinBox_TotalTime_ms.value())
            fitStart = float(self.doubleSpinBox_FilterStart_ms.value()) + 5
            self.doubleSpinBox_FITStart_ms.setValue(fitStart)
            fitStop = float(self.doubleSpinBox_FilterStop_ms.value()) - 5
            self.doubleSpinBox_FITStop_ms.setValue(fitStop)
            self.doubleSpinBox_FIT_f0.setValue(self.doubleSpinBox_Frequency_Hz.value())
            self.FITSampleRate = self.scp.scp.sample_frequency

            self.fit()

    # The fit function must be static
    @staticmethod
    def FITfunc(x, freq, a, b, gamma, dc):
        return (a * np.sin(2 * np.pi * freq * x) + b * np.cos(2 * np.pi * freq * x)) * np.exp(-gamma * x) + dc

    """Plot, fit, filter, analyse..."""

    def fit(self):

        if self.radioButton_FITSource_CH1.isChecked():
            self.dataFIT = self.dataSCPtoFITtab[0]
        else:
            self.dataFIT = self.dataSCPtoFITtab[1]
        totalTime_ms = float(self.doubleSpinBox_FITStop_ms.value())
        t = np.linspace(0, totalTime_ms, len(self.dataFIT), endpoint=False)

        self.dataPlotFIT.clear()
        self.dataPlotFIT.plot(t, self.dataFIT)
        self.dataPlotFIT.setLabel('bottom', "time (ms)")
        self.dataPlotFIT.setLabel('left', "S (V)")

        # cut the data
        nStartUnfiltered = int((self.doubleSpinBox_FilterStart_ms.value() * self.FITSampleRate) / 1000)
        nStopUnfiltered = int((self.doubleSpinBox_FilterStop_ms.value() * self.FITSampleRate) / 1000)
        self.unFilteredDataFit = self.dataFIT[nStartUnfiltered: nStopUnfiltered]

        self.unFilteredDataPlotFIT.clear()
        self.unFilteredDataPlotFIT.plot(t[nStartUnfiltered:nStopUnfiltered], self.unFilteredDataFit)
        self.unFilteredDataPlotFIT.setLabel('bottom', "time (ms)")
        self.unFilteredDataPlotFIT.setLabel('left', "UnFiltered (V)")

        # filter the data
        detrend = signal.detrend(self.unFilteredDataFit, type='constant')
        decimated = signal.decimate(detrend, 5, ftype='fir')  # reduce sample rate 5x
        print(len(self.unFilteredDataFit))
        print(len(decimated), len(self.unFilteredDataFit)/len(decimated))
        decimated = signal.decimate(decimated, 4, ftype='fir')  # reduce sample rate 4x
        print(len(decimated), len(self.unFilteredDataFit) / len(decimated))

        # filter the data
        fb1, fb2 = 1000, 10000
        filterLength = 301  # must be odd number!!!!!!!!!!!!!!!!!!!!
        # drop = int((filterLength - 1) / 2)
        fltr = signal.firwin(filterLength, [fb1, fb2], pass_zero=False, fs=self.FITSampleRate / 20.)

        filtered = signal.convolve(decimated - np.mean(decimated), fltr, mode='valid')
        self.filteredDataFIT = signal.detrend(filtered, type='constant')
        n = len(self.filteredDataFIT)
        tf = 1000 * np.linspace(0, (n * 20.) / self.FITSampleRate, n, endpoint=False)

        # fit of the data
        # curve_fit

        p0 = [self.doubleSpinBox_FIT_f0.value(),
              self.doubleSpinBox_FIT_A.value(),
              self.doubleSpinBox_FIT_B.value(),
              2 * np.pi * self.doubleSpinBox_FIT_Gamma.value(),  # from Hz to rad^-1
              self.doubleSpinBox_FIT_DC.value()]
        popt, pcov = curve_fit(self.FITfunc, tf/1000., self.filteredDataFIT, p0=p0)
        print("popt = ", popt)
        plainText = "f = {:.2f}\n".format(popt[0])  # +str(popt[0]) + "\n"
        plainText += "A = {:.2f}\n".format(popt[1])
        plainText += "B = {:.2f}\n".format(popt[2])
        plainText += "gamma = {:.2f}\n".format(popt[3]/(2 * np.pi))
        plainText += "dc = {:.2f}\n".format(popt[4])
        self.plainTextEdit_FITResults.setPlainText(plainText)

        fitCurve = self.FITfunc(tf/1000., *popt)
        self.FITdataPlotFIT.clear()
        self.FITdataPlotFIT.plot(tf, self.filteredDataFIT, pen=self.penX)
        self.FITdataPlotFIT.plot(tf, fitCurve, pen=self.penZ)
        self.FITdataPlotFIT.setLabel('bottom', "time (ms)")
        self.FITdataPlotFIT.setLabel('left', "FIT (V)")

        self.ResidualsDataPlotFIT.clear()
        self.ResidualsDataPlotFIT.plot(tf, self.filteredDataFIT - fitCurve, pen=self.penY)
        self.FITdataPlotFIT.setLabel('bottom', "time (ms)")
        self.FITdataPlotFIT.setLabel('left', "Residuals (V)")

        """ scipy.signal.periodogram(x, fs=1.0, window='boxcar', nfft=None,
         detrend='constant', return_onesided=True, 
         scaling='density', axis=- 1)
        """
        vsqrtHztext = "(V/&radic;<span style='text-decoration:overline;'>&nbsp;Hz&nbsp;</span>)"
        f, pxx = signal.periodogram(self.unFilteredDataFit, self.FITSampleRate, window='hann')

        self.FFTdataPlotFIT.clear()
        self.FFTdataPlotFIT.setLogMode(y=True)
        self.FFTdataPlotFIT.plot(f / 1000, np.sqrt(pxx))
        self.FFTdataPlotFIT.setLabel('bottom', "Frequency (kHz)")
        self.FFTdataPlotFIT.setLabel('left', "PSD " + vsqrtHztext)

        f, pxx = signal.periodogram(self.filteredDataFIT, self.FITSampleRate/20., window='hann')

        self.FFTFilteredDataPlotFIT.clear()
        self.FFTFilteredDataPlotFIT.setLogMode(y=True)
        self.FFTFilteredDataPlotFIT.plot(f / 1000, np.sqrt(pxx))
        self.FFTFilteredDataPlotFIT.setLabel('bottom', "Frequency (kHz)")
        self.FFTFilteredDataPlotFIT.setLabel('left', "PSD filtered "+ vsqrtHztext)

    def genStartStop(self):
        # self.okButton_GeneratorStart.clicked.connect(self.genStartStop)
        if self.gen.gen.output_on:
            self.gen.stop()
        else:
            self.arbSet()

    def arbSet(self):
        arbObj = arbcalc(totalTime=float(self.doubleSpinBox_TotalTime_ms.value()) / 1000,
                         pumpTime=float(self.doubleSpinBox_PumpTime_ms.value()) / 1000,
                         dutyCycle=float(self.doubleSpinBox_DutyCycle.value()),
                         probeLevel=float(self.doubleSpinBox_ProbeLevel.value()),
                         pumpLevel=float(self.doubleSpinBox_PumpLevel.value()),
                         zeroLevel=float(self.doubleSpinBox_ZeroLevel.value()),
                         pumpFrequency=float(self.doubleSpinBox_Frequency_Hz.value()),
                         noPoints=int(self.doubleSpinBox_Points.value())
                         )
        arb = arbObj.arb()
        t, y = arb
        if not self.gen.arbLoad(y,
                                amplitude=max(y),
                                frequency=1000 / float(self.doubleSpinBox_TotalTime_ms.value())):
            self.statusbar.showMessage("The Generator is not accesible.", 2000)

        self.plotArb(t, y)
        self.gen.start()


##############################################################################################
#
#                    Start the app
#
##############################################################################################

def main():
    app = QtWidgets.QApplication(sys.argv)
    app.setStyleSheet(qdarkgraystyle.load_stylesheet())
    MainWindow = QtWidgets.QMainWindow()
    ui = MyUi()
    ui.setupUi(MainWindow)
    MainWindow.show()

    sys.exit(app.exec_())
    # del MainWindow


if __name__.endswith('__main__'):
    main()
